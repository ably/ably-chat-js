---
notice: This file is autogenerated from the script `copilot-from-cursor.ts`. Run `npm run copilot:from-cursor` to generate it.
---

#### START OF FILE feature-specification.mdc ####
---
description: 
globs: 
alwaysApply: false
---
# Feature Specification

This library is backed by a feature specification, stored in another repository. Specification points are in the following format:

```text
  ** @(CHA-M10e)@ @[Testable]@ To sort @Message@ @versions@ of the same @Message@ (instances with the same @serial@) in global order, sort @Message@ instances lexicographically by their @version@ property.
  *** @(CHA-M10e1)@ @[Testable]@ Two @Message@ instances of the same @serial@ are considered the same version if they have the same @version@ property.
  *** @(CHA-M10e2)@ @[Testable]@ Among @Message@ instances of the same @serial@, the one with a lexicographically higher @version@ is newer.
  *** @(CHA-M10e3)@ @[Testable]@ Among @Message@ instances of the same @serial@, the one with a lexicographically lower @version@ is older.
  ** @(CHA-M10f) @[Testable]@ A message version may be deemed older than another via the @isOlderVersionOf@ convenience method. This method returns true IFF the two messages have the same serial, and the given message is "older" by @(CHA-M10e3)@.
```

- The points are nested
  - A point like CHA-M10 is the top-level
  - A point like CHA-M10a is a sub-point of the top-level
  - A point like CHA-M10a1 is a sub-point of the second-level point
- The `@[Testable]@` annotation means that there MUST be a unit test that accompanies it.
- Specification points without a `@[Testable]@` annotation are intended to be informative or relevant blurb.

# Documenting The Spec

Whenever you are given a specification point for a particular piece of instruction (either directly, or in reference to some other instruction) you must:
  - Include an annotation of the specification point at the relevant section of the code, e.g. `// @CHA-M10a`
  - Include an annotation of the specification point in the relevant test methods, e.g `// CHA-M10a`.
#### START OF FILE file-conventions.mdc ####
---
description: Creating new files and project structure
globs: src/**/*.ts,src/**/*.tsx,test/**/*.ts,test/**/*.tsx
---

# File Creation

- Create all Typescript and TSX files using kebab-case.

# Project Structure

- The `src/core` folder contains the "core" TypeScript SDK.
- The `src/react` folder contains the react hooks and other helpers.
- The `demo/` folder is a React probject that is a demo app for the main library.
- The `test/core` folder contains the tests for the "core" TypeScript SDK.
- The `test/react` folder contains the tests for the react hooks.
#### START OF FILE general.mdc ####
---
description: 
globs: 
alwaysApply: true
---
# Keep It Simple

When you are asked to make a change, don't make any changes that you're not asked for.

If you see an opportunity for improvement, make a suggestion and ask for approval to make the change.

# Always update the tests

Update the tests whenever you make a change.

Always run the tests after making changes to source code or tests in order to catch any regressions.

#### START OF FILE integration-testing.mdc ####
---
description: Writing integration tests
globs: *.integration.test.ts,*.integration.test.tsx
alwaysApply: false
---
# Integration Testing Guide

## How Integration Tests Work

Integration tests are intended to test behaviour whilst interacting with a real Ably service.

## Rules

- Always run tests after you modify them.

## Test Structure

### Basic Test Structure
We use the vitest framework. Each integration test file should follow this basic structure:

```typescript
import { beforeEach, describe, expect, it } from 'vitest';
// Import the modules being tested
import { YourModule } from './your-module';

interface TestContext {
  // Define your test context interface
}

describe('module integration', { timeout: 10000 }, () => {
  beforeEach<TestContext>((context) => {
    // Set up your test context
  });

  it<TestContext>('should do something specific', async (context) => {
    // Test implementation
  });
});
```

### Test Context
Test context is used to share common setup between tests. Define an interface for your test context and use it consistently:

```typescript
interface TestContext {
  chat: ChatClient;
  // Add other context properties as needed
}

describe('integration tests', () => {
  beforeEach<TestContext>((context) => {
    context.chat = newChatClient();
    // Initialise other context properties
  });
});
```

## Test Organization

### Grouping Tests
- Group related tests using `describe` blocks
- Use nested describes for sub-features
- Example:
  ```typescript
  describe('ChatMessage', () => {
    describe('message versions', () => {
      it('is deleted', () => {
        // Test implementation
      });
      
      it('is updated', () => {
        // Test implementation
      });
    });
  });
  ```

## Test Setup Helpers

### `newChatClient()`

This creates a Chat Client that is fully connected and ready to talk to a sandbox Ably service.

## Async Testing

### Handling Async Operations
For async operations, always use async/await and proper timeout handling:

```typescript
it<TestContext>('should handle async operations', async (context) => {
  const { chat } = context;
  
  // Use await for async operations
  const result = await chat.someAsyncOperation();
  
  expect(result).toBeDefined();
});
```
### Async Events

Use `vi.waitFor` to wait for async events to happen.

## Mocking

As these are integreation tests, do **not** mock modules.

Use full `Ably.Realtime` clients to talk to a real Ably service.

#### START OF FILE react-conventions.mdc ####
---
description: Conventions for the React package
globs: src/react/**/*.tsx,src/react/**/*.ts
alwaysApply: false
---
# React Conventions

## Custom Hooks

### Naming Conventions
- Use camelCase for hook names
- Prefix all hooks with `use` (e.g., `useMessages`, `useLogger`)
- Use descriptive names that reflect the hook's purpose

### Hook Documentation
- Use JSDoc style comments for hooks
- Include clear description of the hook's purpose
- Document all parameters and return values using `@param`, `@returns` and `@throws` etc
```typescript
/**
 * A hook that provides access to the Messages instance in the room.
 * @param params - Allows registering optional callbacks
 * @returns UseMessagesResponse - Object containing Messages instance
 */
```

### Hook Parameters

- Group related parameters into a single params object
- Use TypeScript interfaces to define parameter shapes

```typescript
export interface UseMessagesParams extends StatusParams, Listenable<MessageListener> {
  listener?: MessageListener;
}
```

### Hook Return Values

- Return objects with named properties for clarity
- Define return type interfaces explicitly
- Document each returned property

```typescript
export interface UseMessagesResponse extends ChatStatusResponse {
  readonly send: Messages['send'];
  readonly update: Messages['update'];
  // ... other properties
}
```

### Performance Optimization

- Memoize callbacks with `useCallback`
- Memoize expensive computations with `useMemo`
- Use refs for values that shouldn't trigger re-renders
```typescript
const listenerRef = useEventListenerRef(params?.listener);
```

### Cleanup and Resource Management

- Always clean up subscriptions and listeners
- Handle component unmounting gracefully
- Clear timers and intervals in cleanup functions

## Exports

We export the public API types in [index.ts](mdc:src/react/index.ts) If you change any types that are part of the public API, update them here.
#### START OF FILE testing.mdc ####
---
description: Test helpers
globs: *.test.ts,*.test.tsx
---
# Test Helpers Guide

This guide provides an overview of the testing utilities and helpers available in the Ably Chat JS SDK.

## Core Test Setup

### Test Environment Setup (`test-setup.ts`)
- Automatically creates a new app in the sandbox environment before tests run
- Handles API key setup for testing
- Skips setup when using local realtime cluster
- Sets `process.env.sandboxApiKey` for test authentication


## Error Testing Utilities (`expectations.ts`)

Many error testing utilities that extend `expect` in vitest exist in [expectations.ts](mdc:test/helper/expectations.ts).

### Custom Matchers

The following custom matchers are available for testing Ably error scenarios. Whenever testing that an error is thrown, or a promise is rejected, use these.

#### `toBeErrorInfo(received, expected)`

Validates that an error matches expected ErrorInfo properties:
- `code`: Error code
- `statusCode`: HTTP status code
- `message`: Error message
- `cause`: Nested error cause

```typescript
expect(error).toBeErrorInfo({
  code: 40142,
  message: "Expected error message"
});
```

#### `toThrowErrorInfo(received, expected)`

Checks if a function throws an error matching expected ErrorInfo properties:

```typescript
expect(() => someFunction()).toThrowErrorInfo({
  code: 40142
});
```

#### `toBeErrorInfoWithCode(received, expected)`

Validates that an error has a specific error code:

```typescript
expect(error).toBeErrorInfoWithCode(40142);
```

#### `toThrowErrorInfoWithCode(received, expected)`

Checks if a function throws an error with a specific code:

```typescript
expect(() => someFunction()).toThrowErrorInfoWithCode(40142);
```

#### `toBeErrorInfoWithCauseCode(received, expected)`

Validates that an error has a cause with a specific error code:

```typescript
expect(error).toBeErrorInfoWithCauseCode(40142);
```

## React Hook Testing Utilities (`wait-for-eventual-hook.ts`)

### Async Hook Testing
Utilities for testing asynchronous React hooks:

#### `waitForEventualHookValueToBeDefined<T>`

Waits for a hook value to become defined:

```typescript
await waitForEventualHookValueToBeDefined(result, (value) => value.someProperty);
```

#### `waitForEventualHookValue<HookReturn, Value>`
Waits for a hook to return an expected value:

```typescript
await waitForEventualHookValue(
  result,
  expectedValue,
  (current) => current.someProperty
);
```

Default timeout for hook utilities: 3000ms

## Common Test Patterns

### Testing Error Scenarios
```typescript
test('handles specific error', () => {
  expect(() => functionThatThrows()).toThrowErrorInfo({
    code: 40142,
    message: 'Expected error message'
  });
});
```

### Testing Async Hooks
```typescript
test('hook eventually returns value', async () => {
  const { result } = renderHook(() => useMyHook());
  await waitForEventualHookValue(
    result,
    'expected value',
    (current) => current.value
  );
});
```

### Test Waiting For Events

Use vi.waitFor to wait for asynchronous events to happen.

```typescript
  await vi.waitFor(...);
```

## Feature Specificaiton

Refer to [feature-specification.mdc](mdc:.cursor/rules/feature-specification.mdc) for information on how to handle feature specification points in tests.

#### START OF FILE typescript-conventions.mdc ####
---
description: Typescript coding conventions
globs: *.ts,*.tsx
alwaysApply: false
---
# TypeScript Coding Conventions

## Imports

- When importing in this project, use relative imports.
- When importing the package ably, do `import * as Ably from 'ably'`

## Exports

- Export interfaces and types that are part of the public API, make sure you add them to the relevant index.ts: [index.ts](mdc:src/core/index.ts) or [index.ts](mdc:src/react/index.ts)
- Use named exports over default exports
- Group related exports together

```typescript
export interface Messages extends EmitsDiscontinuities {
  // Interface members
}
```

## Interface and Type Declarations

### Interface Naming
- Use PascalCase for interface names
- Use descriptive names that reflect the purpose
- Prefix interfaces with 'I' is not required
```typescript
interface MessageEventPayload {
  type: MessageEvents;
  message: Message;
}
```

### Interface Documentation
- Use JSDoc style comments for interfaces
- Include a clear description of the interface's purpose
- Document all properties inline, alongside the property itself.
- Document all errors using `@throws`.
- Document the return type using `@return`
- Link using {@link} to types mentioned.
```typescript
/**
 * Parameters for querying messages in a chat room.
 */
interface HistoryParams {
  /**
   * The start of the time window to query from.
   * @defaultValue The beginning of time
   */
  start?: number;
}
```

## Enums

### Enum Declarations
- Use PascalCase for enum names
- Use PascalCase for enum members
- Include JSDoc documentation for both enum and members
```typescript
export enum OrderBy {
  /**
   * Return results in ascending order (oldest first).
   */
  OldestFirst = 'oldestFirst',

  /**
   * Return results in descending order (newest first).
   */
  NewestFirst = 'newestFirst',
}
```

## Classes

### Class Structure
- Use PascalCase for class names
- Implement interfaces explicitly
- Avoid extension wherever possible.
- Document class purpose and implementation details.

```typescript
/**
 * @inheritDoc
 */
export class DefaultMessages
  extends EventEmitter<MessageEventsMap>
  implements Messages, HandlesDiscontinuity {
  // Class implementation
}
```

### Class Members
- Use underscore prefix for private members
- Group members by visibility (private, protected, public)
- Document all public methods and properties

```typescript
private readonly _roomId: string;
private readonly _channel: Ably.RealtimeChannel;
```

## Methods

### Method Documentation
- Use JSDoc for all public methods
- Make use of `@param`, `@returns` and `@throws`
```typescript
/**
 * Subscribe to new messages in this chat room.
 * @param listener callback that will be called
 * @returns A response object that allows you to control the subscription.
 */
subscribe(listener: MessageListener): MessageSubscriptionResponse;
```

### Method Parameters
- Use descriptive parameter names
- Group related parameters into parameter objects, rather than having many parameters.
- Use optional parameters with default values when appropriate

```typescript
async update(
  message: Message,
  update: UpdateMessageParams,
  details?: OperationDetails
): Promise<Message>
```

## Error Handling

### Error Types
- The error type used is `ErrorInfo` from the package 'ably' - here [ably.d.ts](mdc:node_modules/ably/ably.d.ts)
  - The first argument is the message, this should be descriptive.
  - The second argument is the error code.
  - The third argument is the status code. When the error code is in the 10000-59999 range, the status code will be the HTTP status code that matches the first 3 numbers.
- Specific error codes can be found in the `ErrorCodes` enum in the [errors.ts](mdc:src/core/errors.ts) file.

### Error Message Format
All error messages MUST follow the pattern: `"unable to <operation>; <reason>"`

**Guidelines:**
- Always start with "unable to" followed by the operation in lowercase
- Use a semicolon (`;`) to separate the operation from the reason
- The operation should describe what action was being attempted
- The reason should explain why the operation failed

**Examples:**
```typescript
// Good examples
throw new Ably.ErrorInfo(
  'unable to send message; room is not attached',
  ErrorCode.RoomInInvalidState,
  400,
);

throw new Ably.ErrorInfo(
  'unable to get room; room already exists with different options',
  ErrorCode.RoomExistsWithDifferentOptions,
  400,
);

throw new Ably.ErrorInfo(
  'unable to subscribe to presence; presence events are not enabled',
  ErrorCode.FeatureNotEnabledInRoom,
  400,
);

throw new Ably.ErrorInfo(
  'unable to query messages; component unmounted',
  ErrorCode.ReactComponentUnmounted,
  400,
) as unknown as Error;
```

**Common patterns to avoid:**
- ❌ `"cannot do something, reason"` (use semicolon, not comma)
- ❌ `"could not do something"` (use "unable to")
- ❌ `"failed to do something"` (use "unable to")
- ❌ `"invalid configuration"` (missing operation context)
- ✅ `"unable to do something; reason"` (correct format)

## Logging

### Logging Conventions
- Use consistent logging levels (trace, debug, error)
- Most method calls (for key classes like messages, presence, room status) will have a trace level log at the top. Don't worry about this for data classes etc.
- Include relevant context in log messages, the second argument is a free-formed object for any relevant context.
- Never log instances of Ably channels, this doesn't work.
- Structure log messages for easy parsing.

```typescript
this._logger.trace('Messages.subscribe();');
this._logger.debug('Messages.update(); message update successfully', { updatedMessage });
```

## Type Safety

### Type Assertions

- Minimize use of type assertions
- Use type guards when possible
- Document when and why type assertions are necessary
- Never use `any`. If we really can't avoid it, use `unknown`, but strong typing always preferred.

```typescript
const channelWithProperties = this._channel as Ably.RealtimeChannel & {
  properties: {
    attachSerial: string | undefined;
    channelSerial: string | undefined;
  };
};
```

## Promises and Async

### Async/Await
- Use async/await over raw promises
- Handle promise rejections appropriately
- Document asynchronous behavior

```typescript
async send(params: SendMessageParams): Promise<Message> {
  this._logger.trace('Messages.send();', { params });
  const response = await this._chatApi.sendMessage(this._roomId, params);
  return new DefaultMessage(/* ... */);
}
```

## Exports

We export the public API types in [index.ts](mdc:src/core/index.ts). If you change any types that are part of the public API, update them here.

## Feature Specification

Refer to [feature-specification.mdc](mdc:.cursor/rules/feature-specification.mdc) for information on how to handle feature specification points in code.

#### START OF FILE unit-testing.mdc ####
---
description: Unit testing guide
globs: *.test.ts,*.test.tsx
alwaysApply: false
---
# Unit Testing Guide

## Table of Contents
0. Rules
1. [Test Structure](mdc:#test-structure)
2. [Naming Conventions](mdc:#naming-conventions)
3. [Test Organization](mdc:#test-organization)
4. [Test Cases](mdc:#test-cases)
5. [Assertions](mdc:#assertions)
6. [Test Data](mdc:#test-data)
7. [Best Practices](mdc:#best-practices)

## Rules

- Always run tests after you modify them.

## Test Structure

### Mocking Ably

The `ably` library is mocked in mocks, and should be mocked as a module, for example:

```ts
  import * as Ably from 'ably';
  import { describe, expect, it, vi } from 'vitest';

  vi.mock('ably');

  // The rest of the test file
```

### Basic Test Structure

We use Vitest as our testing framework. Each test file should follow this basic structure:

```typescript
import { describe, expect, it } from 'vitest';
// Import the modules being tested
import { YourModule } from './your-module';

describe('ModuleName', () => {
  it('should do something specific', () => {
    // Test implementation
  });
});
```

## Naming Conventions

### Test File Names
- Test files should end with `.test.ts`
- Name should reflect the module being tested
- Example: `message.test.ts` for testing `message.ts`

### Test Descriptions
- Use clear, descriptive names that explain the test's purpose
- Format: `it('should [expected behavior]')`
- Examples:
  ```typescript
  it('is the same as another message')
  it('is not the same as another message')
  it('should return false when trying to compare versions belonging to different origin messages')
  ```

## Test Organization

### Grouping Tests
- Group related tests using `describe` blocks
- Use nested describes for sub-features
- Example:
  ```typescript
  describe('ChatMessage', () => {
    describe('message versions', () => {
      it('is deleted', () => {
        // Test implementation
      });
      
      it('is updated', () => {
        // Test implementation
      });
    });
  });
  ```

## Test Cases

### Test Case Structure
1. Arrange: Set up test data and conditions
2. Act: Execute the code being tested
3. Assert: Verify the results

Example:
```typescript
it('is deleted', () => {
  // Arrange
  const firstSerial = '01672531200000-124@abcdefghij:0';
  const firstMessage = new DefaultMessage(
    firstSerial,
    'clientId',
    'roomId',
    'hello there',
    {},
    {},
    ChatMessageActions.MessageDelete,
    '01672531300000-123@abcdefghij:0',
    new Date(1672531200000),
    new Date(1672531300000),
    {
      clientId: 'clientId2',
    }
  );

  // Act & Assert
  expect(firstMessage.isDeleted).toBe(true);
  expect(firstMessage.deletedBy).toBe('clientId2');
});
```

### Testing Multiple Scenarios
- Test both positive and negative cases
- Test edge cases and boundary conditions
- Example:
  ```typescript
  it('is the same as another message')
  it('is not the same as another message')
  ```

## Assertions

### Using Expect
- Use clear, specific assertions
- Chain assertions when testing multiple aspects
- Example:
  ```typescript
  expect(firstMessage.equal(secondMessage)).toBe(true);
  expect(firstMessage.isDeleted).toBe(true);
  expect(firstMessage.deletedBy).toBe('clientId2');
  ```

### Common Assertions
- `toBe()`: Strict equality
- `toEqual()`: Deep equality
- `toBeTruthy()/toBeFalsy()`: Boolean conditions
- `toThrowErrorInfo()`: Error cases

## Test Data

### Test Data Setup
- Create meaningful test data that clearly demonstrates the test case
- Use constants for repeated values
- Example:
  ```typescript
  const firstSerial = '01672531200000-123@abcdefghij';
  const secondSerial = '01672531200000-124@abcdefghij';

### Error Testing

Test error cases explicitly:

```typescript
it('should throw an error if different messages', () => {
  // Arrange
  const message = // ... setup message
  const event = // ... setup event

  // Act & Assert
  expect(() => message.with(event)).toThrowErrorInfo({
    code: 40000,
    statusCode: 400,
    message: 'cannot apply event for a different message',
  });
});
```

If handling promises, it's the same principle but a different method:

```ts
it('should throw an error if different messages', async () => {
  // Arrange
  const message = // ... setup message
  const event = // ... setup event

  // Act & Assert
  await expect(() => message.with(event)).rejects.toBeErrorInfo({
    code: 40000,
    statusCode: 400,
    message: 'cannot apply event for a different message',
  });
});
```

## Rooms

Use random room IDs to avoid conflicts.

## Data Driven Tests

Use .each to write table/data driven tests.

